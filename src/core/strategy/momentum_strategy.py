"""
RSI Momentum Strategy for PDT Trading Bot

RSI crossover strategy optimized for volatile stocks/ETFs under $10/share
to maximize trade frequency and reach PDT volume thresholds quickly.
"""

import asyncio
import numpy as np
import talib
from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from decimal import Decimal
from enum import Enum
from threading import Event
from typing import Dict, List, Optional, Any, Callable, Tuple
import structlog
import pandas as pd
from collections import deque


class SignalType(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class StrategyConfig:
    """Configuration for momentum strategy."""
    # RSI parameters
    rsi_period: int = 14
    rsi_oversold: float = 30.0
    rsi_overbought: float = 70.0

    # Strategy parameters
    lookback_period: int = 50
    min_volume: int = 10000
    max_position_pct: Decimal = Decimal('0.05')  # 5% max position size
    min_price: float = 1.0
    max_price: float = 10.0  # Focus on sub-$10 stocks for PDT optimization

    # Signal filtering
    min_signal_strength: float = 0.02  # Minimum price movement to trigger signal
    cooldown_period: int = 5  # Minutes between signals for same symbol

    # PDT optimization
    target_trade_frequency: int = 10  # Trades per day target
    volume_threshold: Decimal = Decimal('25000')  # PDT threshold


@dataclass
class PriceData:
    """Market price data point."""
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int


@dataclass
class TradingSignal:
    """Trading signal generated by strategy."""
    symbol: str
    signal_type: SignalType
    price: Decimal
    quantity: int
    confidence: float
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    metadata: Dict[str, Any] = field(default_factory=dict)


class MomentumStrategy:
    """
    RSI-based momentum strategy optimized for PDT requirements.

    Uses RSI crossovers to generate buy/sell signals for volatile,
    low-priced stocks to maximize trade frequency and volume.
    """

    def __init__(self, max_position_size: Decimal = Decimal('0.05'), shutdown_event: Optional[Event] = None):
        self.config = StrategyConfig()
        self.max_position_size = max_position_size
        self.shutdown_event = shutdown_event or Event()
        self.logger = structlog.get_logger("momentum_strategy")

        # Signal callback
        self._signal_callback: Optional[Callable[[Dict[str, Any]], None]] = None

        # Market data storage (thread-safe)
        self._price_data: Dict[str, deque] = {}
        self._data_lock: Dict[str, asyncio.Lock] = {}

        # Signal tracking for cooldowns
        self._last_signal: Dict[str, datetime] = {}
        self._active_signals: Dict[str, TradingSignal] = {}

        # Performance tracking
        self.signals_generated = 0
        self.signals_executed = 0
        self.strategy_returns = Decimal('0')

        self.logger.info("Momentum strategy initialized",
                        rsi_period=self.config.rsi_period,
                        max_position_pct=float(max_position_size))

    def set_signal_callback(self, callback: Callable[[Dict[str, Any]], None]):
        """Set callback for generated trading signals."""
        self._signal_callback = callback

    async def initialize(self):
        """Initialize strategy components."""
        self.logger.info("Initializing momentum strategy")

        # Initialize data structures for tracked symbols
        # Will be populated as symbols are added

        self.logger.info("Momentum strategy initialized successfully")

    async def shutdown(self):
        """Shutdown strategy and cleanup resources."""
        self.logger.info("Shutting down momentum strategy")

        # Clear all data
        self._price_data.clear()
        self._active_signals.clear()
        self._last_signal.clear()

        self.logger.info("Momentum strategy shutdown complete")

    async def process_market_data(self, symbol: str, price_data: Dict[str, Any]):
        """
        Process incoming market data and generate trading signals.

        Args:
            symbol: Stock symbol
            price_data: Current price and volume data
        """
        try:
            # Skip if shutting down
            if self.shutdown_event.is_set():
                return

            # Validate price data
            if not self._validate_price_data(price_data):
                return

            # Update price history
            await self._update_price_history(symbol, price_data)

            # Check if we have enough data for analysis
            if not await self._has_sufficient_data(symbol):
                return

            # Generate trading signal
            signal = await self._generate_signal(symbol, price_data)

            if signal and signal.signal_type != SignalType.HOLD:
                await self._process_signal(signal)

        except Exception as e:
            self.logger.error("Error processing market data",
                            symbol=symbol,
                            error=str(e),
                            exc_info=True)

    def _validate_price_data(self, price_data: Dict[str, Any]) -> bool:
        """Validate incoming price data."""
        required_fields = ['price', 'volume', 'timestamp']

        for field in required_fields:
            if field not in price_data:
                self.logger.warning("Missing required field in price data", field=field)
                return False

        # Validate price and volume are positive
        try:
            price = float(price_data['price'])
            volume = int(price_data['volume'])

            if price <= 0 or volume <= 0:
                self.logger.warning("Invalid price or volume",
                                  price=price,
                                  volume=volume)
                return False

            return True

        except (ValueError, TypeError) as e:
            self.logger.warning("Error parsing price data", error=str(e))
            return False

    async def _update_price_history(self, symbol: str, price_data: Dict[str, Any]):
        """Update price history for symbol."""
        if symbol not in self._data_lock:
            self._data_lock[symbol] = asyncio.Lock()

        async with self._data_lock[symbol]:
            if symbol not in self._price_data:
                self._price_data[symbol] = deque(maxlen=self.config.lookback_period * 2)

            # Create price data point
            data_point = PriceData(
                timestamp=datetime.fromisoformat(price_data['timestamp'].replace('Z', '+00:00')),
                open=float(price_data.get('open', price_data['price'])),
                high=float(price_data.get('high', price_data['price'])),
                low=float(price_data.get('low', price_data['price'])),
                close=float(price_data['price']),
                volume=int(price_data['volume'])
            )

            self._price_data[symbol].append(data_point)

    async def _has_sufficient_data(self, symbol: str) -> bool:
        """Check if we have sufficient data for analysis."""
        async with self._data_lock[symbol]:
            return (symbol in self._price_data and
                   len(self._price_data[symbol]) >= self.config.rsi_period + 10)

    async def _generate_signal(self, symbol: str, current_data: Dict[str, Any]) -> Optional[TradingSignal]:
        """Generate trading signal based on RSI analysis."""
        async with self._data_lock[symbol]:
            price_history = list(self._price_data[symbol])

            if len(price_history) < self.config.rsi_period:
                return None

            # Extract price series for technical analysis
            closes = np.array([p.close for p in price_history])
            volumes = np.array([p.volume for p in price_history])

            # Calculate RSI
            rsi = talib.RSI(closes, timeperiod=self.config.rsi_period)

            if len(rsi) < 2:
                return None

            current_rsi = rsi[-1]
            previous_rsi = rsi[-2]
            current_price = float(current_data['price'])

            # Check price range for PDT optimization
            if not (self.config.min_price <= current_price <= self.config.max_price):
                return None

            # Check minimum volume
            current_volume = int(current_data['volume'])
            if current_volume < self.config.min_volume:
                return None

            # Check signal cooldown
            if not self._check_signal_cooldown(symbol):
                return None

            # Generate signals based on RSI crossovers
            signal = self._analyze_rsi_signal(symbol, current_price, current_rsi, previous_rsi)

            if signal:
                # Calculate position size
                quantity = self._calculate_position_size(symbol, current_price, signal.signal_type)

                if quantity > 0:
                    signal.quantity = quantity
                    signal.price = Decimal(str(current_price))

                    # Calculate confidence based on RSI distance from thresholds
                    signal.confidence = self._calculate_signal_confidence(current_rsi, signal.signal_type)

                    return signal

            return None

    def _analyze_rsi_signal(self, symbol: str, price: float, rsi: float, prev_rsi: float) -> Optional[TradingSignal]:
        """Analyze RSI for buy/sell signals."""
        # Oversold condition (RSI crosses above threshold)
        if prev_rsi <= self.config.rsi_oversold < rsi:
            return TradingSignal(
                symbol=symbol,
                signal_type=SignalType.BUY,
                price=Decimal(str(price)),
                quantity=0,  # Will be calculated
                confidence=0.0,
                metadata={
                    'rsi': rsi,
                    'prev_rsi': prev_rsi,
                    'signal_type': 'oversold_crossover'
                }
            )

        # Overbought condition (RSI crosses below threshold)
        elif prev_rsi >= self.config.rsi_overbought > rsi:
            return TradingSignal(
                symbol=symbol,
                signal_type=SignalType.SELL,
                price=Decimal(str(price)),
                quantity=0,  # Will be calculated
                confidence=0.0,
                metadata={
                    'rsi': rsi,
                    'prev_rsi': prev_rsi,
                    'signal_type': 'overbought_crossover'
                }
            )

        return None

    def _calculate_position_size(self, symbol: str, price: float, signal_type: SignalType) -> int:
        """Calculate optimal position size for PDT optimization."""
        # For PDT optimization, we want to maximize trade frequency
        # while staying within risk limits

        # Base position size on available capital and max position percentage
        # This will be refined when we have account balance from risk manager

        # For now, use a minimum trade size that contributes to PDT volume
        min_trade_value = 100  # $100 minimum trade value

        quantity = int(min_trade_value / price)

        # Ensure minimum quantity for market impact
        quantity = max(quantity, 1)

        # For sell signals, we can only sell what we have
        if signal_type == SignalType.SELL:
            # This will be validated by risk manager with actual position
            pass

        return quantity

    def _calculate_signal_confidence(self, rsi: float, signal_type: SignalType) -> float:
        """Calculate confidence level for the signal."""
        if signal_type == SignalType.BUY:
            # Distance from oversold level (lower RSI = higher confidence)
            distance_from_threshold = self.config.rsi_oversold - rsi
            max_distance = self.config.rsi_oversold
            confidence = max(0, min(1, distance_from_threshold / max_distance))

        elif signal_type == SignalType.SELL:
            # Distance from overbought level (higher RSI = higher confidence)
            distance_from_threshold = rsi - self.config.rsi_overbought
            max_distance = 100 - self.config.rsi_overbought
            confidence = max(0, min(1, distance_from_threshold / max_distance))

        else:
            confidence = 0.0

        return confidence

    def _check_signal_cooldown(self, symbol: str) -> bool:
        """Check if enough time has passed since last signal for this symbol."""
        if symbol not in self._last_signal:
            return True

        time_since_last = datetime.now(timezone.utc) - self._last_signal[symbol]
        cooldown_seconds = self.config.cooldown_period * 60

        return time_since_last.total_seconds() >= cooldown_seconds

    async def _process_signal(self, signal: TradingSignal):
        """Process and emit trading signal."""
        try:
            # Update signal tracking
            self._last_signal[signal.symbol] = signal.timestamp
            self._active_signals[signal.symbol] = signal
            self.signals_generated += 1

            self.logger.info("Generated trading signal",
                           symbol=signal.symbol,
                           signal_type=signal.signal_type.value,
                           price=float(signal.price),
                           quantity=signal.quantity,
                           confidence=signal.confidence,
                           rsi=signal.metadata.get('rsi'))

            # Emit signal via callback
            if self._signal_callback:
                await self._emit_signal(signal)

        except Exception as e:
            self.logger.error("Error processing signal",
                            symbol=signal.symbol,
                            error=str(e))

    async def _emit_signal(self, signal: TradingSignal):
        """Emit signal to registered callback."""
        try:
            signal_data = {
                'symbol': signal.symbol,
                'action': signal.signal_type.value,
                'quantity': signal.quantity,
                'price': float(signal.price),
                'confidence': signal.confidence,
                'timestamp': signal.timestamp.isoformat(),
                'metadata': signal.metadata
            }

            if self._signal_callback:
                await asyncio.get_event_loop().run_in_executor(
                    None, self._signal_callback, signal_data
                )

        except Exception as e:
            self.logger.error("Error emitting signal",
                            symbol=signal.symbol,
                            error=str(e))

    def get_strategy_stats(self) -> Dict[str, Any]:
        """Get strategy performance statistics."""
        return {
            'signals_generated': self.signals_generated,
            'signals_executed': self.signals_executed,
            'active_signals': len(self._active_signals),
            'tracked_symbols': len(self._price_data),
            'strategy_returns': float(self.strategy_returns),
            'config': {
                'rsi_period': self.config.rsi_period,
                'rsi_oversold': self.config.rsi_oversold,
                'rsi_overbought': self.config.rsi_overbought,
                'max_position_pct': float(self.config.max_position_pct)
            }
        }

    def update_signal_result(self, symbol: str, executed: bool, pnl: Optional[Decimal] = None):
        """Update signal execution results."""
        if executed:
            self.signals_executed += 1

        if pnl is not None:
            self.strategy_returns += pnl

        # Remove from active signals if executed
        if symbol in self._active_signals:
            del self._active_signals[symbol]